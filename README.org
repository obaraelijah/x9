#+AUTHOR: Elijah Samson

* The x9 Programming Language

x9 is a lisp I built to better understand programming languages and interpreters.

The standard library is being written in either x9 or rust for performance.

** Features
*** Usual Lispy Goodness

You have brackets. Lots of brackets. And lists. And functions.

*** Self-documenting

The goal is to have every function describe itself, so you can live in the repl.

Use the =doc= function on a symbol to see it's documentation:

#+begin_example
>>> (print (doc foreach))
Eagerly apply the given function to a sequence or list.
Example:
(foreach
  (fn (x) (println x))
  (range 20)) ; prints 0 to 20. Returns ().

(foreach
  (fn (x) (println x))
  (take 5 (map (fn (x) (* x x x x x x)) (range)))) ; prints 0, 1, 64, 729, 4096
#+end_example

The general goal is to be as helpful as possible. So stacktraces include more
information than you'd usually get, such as arguments.

For example, the following program will fail:

#+begin_src elisp
(defn bottom (x) (% x 2))
(defn middle (x) (bottom x))
(defn top () (middle "a"))
(top)
#+end_src

And give this helpful stacktrace:

#+begin_example
Error: BadTypes

Stacktrace:
  - Remainder requires left and right are num types, was given "a" % 2
  - Error in Fn<%, 2, [ ]>, with args ("a" 2)
  - Error in Fn<bottom, 1, [ x ]>, with args ("a")
  - Error in Fn<middle, 1, [ x ]>, with args ("a")
  - Error in Fn<top, 0, [ ]>, with args ()
#+end_src
#+end_example

*** Convenient FFI

x9 offers easy and convenient embedding into other rust programs.

#+begin_src rust
  use x9::ffi::{x9Interpreter, ForeignData};

  let interpreter = x9Interpreter::new();
  let res = interpreter.run_program::<u64>("(+ 1 1)").unwrap();
  assert_eq!(res, 2);
#+end_src

You can interface your own types in x9 with the =ForeignData= trait, and
add foreign functions into the interpreter. To maximize convenience foreign functions
are typed in terms of their own datatypes - not x9's Expr type.

#+begin_src rust
  let interpreter = x9Interpreter::new();
  let my_sum_fn = |args: Vec<u64>| Ok(args.iter().sum());
  // Add the my-sum to interpreter
  interpreter.add_function("my-sum", 1, Arc::new(my_sum_fn));

  // And verify we get u64 with value 6 out of it.
  assert_eq!(interpreter.run_program::<u64>("(my-sum 1 2 3)").unwrap(), 6);
#+end_src

More interesting is the fact that functions added to the interpreter
in a strongly typed way, allowing us to mix types!

#+begin_src rust
  // Recall that my-sum is a Fn(Vec<u64>) -> u64
  let string_res = interpreter.run_program::<String>("(my-sum 1 2 3)").unwrap();
  // And we get a string out it!
  assert_eq!(string_res, "6".to_string());
#+end_src

The reason it works is we embed the type information into the function
added to the interpreter, and x9's =Expr= type acts as a bridge between types.

For more info see the =ffi.rs= example in the examples folder!

You can run the example with:

#+begin_example
cargo run --example ffi
#+end_example


*** Speedy Iterators

Certain constructs like =(range)= and =map= are backed by lazy iterators, making them pretty fast.

** Examples

*** Fibonacci Numbers

We can print the first hundred fibonacci numbers in 14 milliseconds:

#+begin_src elisp
;; fib.x9
;; Run with: x9 fib.x9

;; Map (l, r) -> (r, l + r)

(defn fib-step (x)
  (bind ((l r) x) ^(r (+ l r))))

;; Reduce (0 1) `num` times using fib-step to
;; generate the `num`'th fibonacci number

(defn fib (num)
  (nth 0 (reduce
          fib-step
          (tuple 0 1)
          (range num))))

;; Print one hundred fibonacci numbers
;;
;; Note: (take 100 (map fib (range)))
;; is an iterator which maps to Rust's iterators which
;; makes them very fast. No weird intermediate allocations.

(println (time (foreach
                println
                (take 100 (map fib (range))))))
#+end_src

Outputs:

#+begin_example
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
...truncated...
83621143489848422977
135301852344706746049
218922995834555169026
#+end_example

** More Features
*** Dynamic Records and Syntactic Sugar

A recent addition to the language is the =defrecord= and =defmethod= functions,
which allow you to define records in =x9= and add methods to the them respectively.

Here's an example of defining =Vec3=, and a way to add them together:

#+begin_src lisp
  ;; Define a record
  (defrecord Vec3 "Three dimensional vector" x y z)

  ;; Add a method to it
  (defmethod Vec3 +
    "Add two vectors together"
    (other)
    (Vec3
     (+ other.x self.x)
     (+ other.y self.y)
     (+ other.z self.z)))
#+end_src

This lets us encapsulate data, and access it in a nice structured way.

#+begin_src lisp
  ;; Instantiate a Vec3
  (def my-vector (Vec3 1 1 1))

  ;; Call the + method
  (.+ my-vector my-vector) ;; Record<Vec3, fields=[ x: 2 y: 2 z: 2 ]>
#+end_src

The process of adding this support added two
new ways to interact with expressions - callable Records and field-access-sugar

**** Callable Records

To make record construction nice, you can treat records defined with =defrecord= as constructor functions:

#+begin_example
>>> (defrecord Point x y)
Record<Point, uninitialized>
>>> (Point 0 0)
Record<Point, fields=[ x: 0 y: 0 ]>
#+end_example

**** Record Field Syntactic Sugar

By default, fields of a record are treated as zero-arity methods on that record, with =self= being inserted with method_call syntax.

This meant that this got old after a while:

#+begin_example
(+ (.x self) (.x other))
#+end_example

So I added some sugar in the form of =self.x=:

#+begin_example
>>> (defrecord Point x y)
>>> (def origin (Point 0 0))
>>> origin.x
0
#+end_example

It works in a recursive way if you have deeply nested fields.

#+begin_example
>>> (defrecord Point x y)
>>> (defrecord Space origin)
>>> (def space (Space (Point 0 0)))
>>> space.origin
Record<Point, fields=[ x: 0 y: 0 ]>
>>> space.origin.x
0
>>> space.origin.y
0
#+end_example

The syntax immediately evaluates, as it gets transformed a nested list of function calls:

#+begin_example
space.origin.y ;; (.y (.origin space))
#+end_example

You can do some tricks with this, like this:

#+begin_src lisp
  (def file (fs::open "input.txt"))
  (def re (re::compile "(\d+)-(\d+) (.): (.*)"))
  (def captures (.captures re file.read_to_string))
#+end_src

Zero arity functions can also be referenced:

#+begin_example
>>> (def v (Vec3 1 1 1))
nil
>>> v.scale
Fn<curried_method_call<Vec3<scale>; #args=1>, 0, [ ]>
>>> (v.scale 3)
Record<Vec3, fields=[ x: 3 y: 3 z: 3 ]>
>>> v.length
1.73205080
#+end_example