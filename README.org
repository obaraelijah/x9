#+AUTHOR: Elijah Samson

* The x9 Programming Language

x9 is a lisp I built to better understand programming languages and interpreters.

The standard library is being written in either x9 or rust for performance.

** Features
*** Usual Lispy Goodness

You have brackets. Lots of brackets. And lists. And functions.

*** Self-documenting

The goal is to have every function describe itself, so you can live in the repl.

Use the =doc= function on a symbol to see it's documentation:

#+begin_example
>>> (print (doc foreach))
Eagerly apply the given function to a sequence or list.
Example:
(foreach
  (fn (x) (println x))
  (range 20)) ; prints 0 to 20. Returns ().

(foreach
  (fn (x) (println x))
  (take 5 (map (fn (x) (* x x x x x x)) (range)))) ; prints 0, 1, 64, 729, 4096
#+end_example

The general goal is to be as helpful as possible. So stacktraces include more
information than you'd usually get, such as arguments.

For example, the following program will fail:

#+begin_src elisp
(defn bottom (x) (% x 2))
(defn middle (x) (bottom x))
(defn top () (middle "a"))
(top)
#+end_src

And give this helpful stacktrace:

#+begin_example
Error: BadTypes

Stacktrace:
  - Remainder requires left and right are num types, was given "a" % 2
  - Error in Fn<%, 2, [ ]>, with args ("a" 2)
  - Error in Fn<bottom, 1, [ x ]>, with args ("a")
  - Error in Fn<middle, 1, [ x ]>, with args ("a")
  - Error in Fn<top, 0, [ ]>, with args ()
#+end_src
#+end_example

*** Convenient FFI

x9 offers easy and convenient embedding into other rust programs.

#+begin_src rust
  use x9::ffi::{x9Interpreter, ForeignData};

  let interpreter = x9Interpreter::new();
  let res = interpreter.run_program::<u64>("(+ 1 1)").unwrap();
  assert_eq!(res, 2);
#+end_src

You can interface your own types in x9 with the =ForeignData= trait, and
add foreign functions into the interpreter. To maximize convenience foreign functions
are typed in terms of their own datatypes - not x9's Expr type.

#+begin_src rust
  let interpreter = x9Interpreter::new();
  let my_sum_fn = |args: Vec<u64>| Ok(args.iter().sum());
  // Add the my-sum to interpreter
  interpreter.add_function("my-sum", 1, Arc::new(my_sum_fn));

  // And verify we get u64 with value 6 out of it.
  assert_eq!(interpreter.run_program::<u64>("(my-sum 1 2 3)").unwrap(), 6);
#+end_src

More interesting is the fact that functions added to the interpreter
in a strongly typed way, allowing us to mix types!

#+begin_src rust
  // Recall that my-sum is a Fn(Vec<u64>) -> u64
  let string_res = interpreter.run_program::<String>("(my-sum 1 2 3)").unwrap();
  // And we get a string out it!
  assert_eq!(string_res, "6".to_string());
#+end_src

The reason it works is we embed the type information into the function
added to the interpreter, and x9's =Expr= type acts as a bridge between types.

For more info see the =ffi.rs= example in the examples folder!

You can run the example with:

#+begin_example
cargo run --example ffi
#+end_example


*** Speedy Iterators

Certain constructs like =(range)= and =map= are backed by lazy iterators, making them pretty fast.

** Examples

*** Fibonacci Numbers

We can print the first hundred fibonacci numbers in 14 milliseconds:

#+begin_src elisp
;; fib.x9
;; Run with: x9 fib.x9

;; Map (l, r) -> (r, l + r)

(defn fib-step (x)
  (bind ((l r) x) ^(r (+ l r))))

;; Reduce (0 1) `num` times using fib-step to
;; generate the `num`'th fibonacci number

(defn fib (num)
  (nth 0 (reduce
          fib-step
          (tuple 0 1)
          (range num))))

;; Print one hundred fibonacci numbers
;;
;; Note: (take 100 (map fib (range)))
;; is an iterator which maps to Rust's iterators which
;; makes them very fast. No weird intermediate allocations.

(println (time (foreach
                println
                (take 100 (map fib (range))))))
#+end_src

Outputs:

#+begin_example
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
...truncated...
83621143489848422977
135301852344706746049
218922995834555169026
#+end_example

** More Features
*** Dynamic Records and Syntactic Sugar

A recent addition to the language is the =defrecord= and =defmethod= functions,
which allow you to define records in =x9= and add methods to the them respectively.

Here's an example of defining =Vec3=, and a way to add them together:

#+begin_src lisp
  ;; Define a record
  (defrecord Vec3 "Three dimensional vector" x y z)

  ;; Add a method to it
  (defmethod Vec3 +
    "Add two vectors together"
    (other)
    (Vec3
     (+ other.x self.x)
     (+ other.y self.y)
     (+ other.z self.z)))
#+end_src

This lets us encapsulate data, and access it in a nice structured way.

#+begin_src lisp
  ;; Instantiate a Vec3
  (def my-vector (Vec3 1 1 1))

  ;; Call the + method
  (.+ my-vector my-vector) ;; Record<Vec3, fields=[ x: 2 y: 2 z: 2 ]>
#+end_src

The process of adding this support added two
new ways to interact with expressions - callable Records and field-access-sugar

**** Callable Records

To make record construction nice, you can treat records defined with =defrecord= as constructor functions:

#+begin_example
>>> (defrecord Point x y)
Record<Point, uninitialized>
>>> (Point 0 0)
Record<Point, fields=[ x: 0 y: 0 ]>
#+end_example

**** Record Field Syntactic Sugar

By default, fields of a record are treated as zero-arity methods on that record, with =self= being inserted with method_call syntax.

This meant that this got old after a while:

#+begin_example
(+ (.x self) (.x other))
#+end_example

So I added some sugar in the form of =self.x=:

#+begin_example
>>> (defrecord Point x y)
>>> (def origin (Point 0 0))
>>> origin.x
0
#+end_example

It works in a recursive way if you have deeply nested fields.

#+begin_example
>>> (defrecord Point x y)
>>> (defrecord Space origin)
>>> (def space (Space (Point 0 0)))
>>> space.origin
Record<Point, fields=[ x: 0 y: 0 ]>
>>> space.origin.x
0
>>> space.origin.y
0
#+end_example

The syntax immediately evaluates, as it gets transformed a nested list of function calls:

#+begin_example
space.origin.y ;; (.y (.origin space))
#+end_example

You can do some tricks with this, like this:

#+begin_src lisp
  (def file (fs::open "input.txt"))
  (def re (re::compile "(\d+)-(\d+) (.): (.*)"))
  (def captures (.captures re file.read_to_string))
#+end_src

Zero arity functions can also be referenced:

#+begin_example
>>> (def v (Vec3 1 1 1))
nil
>>> v.scale
Fn<curried_method_call<Vec3<scale>; #args=1>, 0, [ ]>
>>> (v.scale 3)
Record<Vec3, fields=[ x: 3 y: 3 z: 3 ]>
>>> v.length
1.73205080
#+end_example

*** Anonymous Function Syntactic Sugar

You can easily create anonymous functions with =#(...)=. Here's an example:

#+begin_src lisp
  (filter #(< $1 10) (range 100)) ;; (0 1 2 3 4 5 6 7 8 9)

  (map #(+ 10 $1) (range 10)) ;; (10 11 12 13 14 15 16 17 18 19)
#+end_src

Fields are labelled =$1, $2, ...=.

** Language Description

x9 is a quirky lisp which sort of evolved naturally. It has the following data-types:

#+begin_src rust
  pub enum Expr {
    Num(Num),
    Integer(Integer),
    Symbol(Symbol),
    List(Vector<Expr>),
    Function(Arc<Function>),
    Nil,
    String(String),
    Quote(Vector<Expr>),
    Tuple(Vector<Expr>),
    Bool(bool),
    LazyIter(IterType),
    Dict(Dict),
    Record(crate::records::RecordType),
}
#+end_src

*** =Num=

Numbers in x9 are arbitrary precision =BigDecimal= types backed by the =bigdecimal= crate.

Example:
#+begin_example
0
0.0
1.1
1000000000000000000
#+end_example

*** =Integer=

A fast-path for integer heavy calculations.
If you can avoid non-whole numbers this is substantially faster than the =Num= type.

Example:
#+begin_example
1
2
-5
#+end_example

*** =Symbol=

Symbols are references to some object in the symbol table. They can't contain quotes or brackets.

Example:
#+begin_example
+
sort
doc
#+end_example

*** =List=

A list is a sequential collection of values. When evaluated, the first argument is called as a function
with the rest of the elements as arguments.

Example:
#+begin_example
(+ 1 2)
(println "hello world!")
#+end_example

*** =Function=

A function is a type defined by the =fn= or =defn= keywords. They accept a variable number
of arguments and carry a local scope. Variables shadow each other, and functions will close over arguments.


Example:
#+begin_src elisp
(defn is-odd?
  (x)
  (= 1 (% x 2))) ; add function is-odd? to symbol table

(map
  (fn (num) (* num num)) ; anon func
  (range 20))

(defn not=
  (& args) ; excess variables can be captured into a list
  (not (apply = args)))
#+end_src

*** =Nil=

Null type. Usually equal to an empty list.

*** =String=

A UTF-8 string of characters between two quotes: "hello world!"

*** =Quote=

An unevaluated list. When evaluated, it turns into a list.

Has special syntax: ='(1 2 3)=
And a keyword: =(quote 1 2 3)=

*** =Tuple=

Same thing as a list, but always evals to itself.

Has special syntax: =^(1 2 3)=
And a keyword: =(tuple 1 2 3)=

*** =Bool=

Classic boolean. True or false.

Example:
#+begin_example
true
false
(= 1 0) ;; false
#+end_example

*** =LazyIter=

A sequence of values backed by a Rust iterator. These are useful for working
with infinite sequences.

Currently, =map=, =filter=, =take=, and =range= can yield lazy iterators.

They are evaluated with =doall= to make a list or =foreach= to operate on it.

Example:

#+begin_example
(doall (take 5 (map inc (range)))) ; (1 2 3 4 5)
; Or
(foreach
  println
  (take 5 (map inc (range)))) ; prints one through five
#+end_example

*** =Dict=

Classic immutable dictionary. This is certainly a work in progress.

Example:
#+begin_example
(def foo (dict "key1" "value1" 3 4))

(get foo 3)  ;; 4
(get foo "key1")  ;; "value1"

(set foo 5 6)  ;; {"key1": "value1", 3: 4, 5: 6}
               ;; This does not mutate `foo`!
(get foo 5)  ;; nil
#+end_example

*** =Record=

Objects in =x9=. See the [[https://github.com/dpbriggs/x9#dynamic-records-and-syntactic-sugar][record section above]].

** Standard Library Reference

The x9 language has self-documenting features. The standard library reference is generated
with the script below, which =org-mode= pastes into the list below: