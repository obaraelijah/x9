#+AUTHOR: Elijah Samson

* The x9 Programming Language

x9 is a lisp I built to better understand programming languages and interpreters.

The standard library is being written in either x9 or rust for performance.

** Features
*** Usual Lispy Goodness

You have brackets. Lots of brackets. And lists. And functions.

*** Self-documenting

The goal is to have every function describe itself, so you can live in the repl.

Use the =doc= function on a symbol to see it's documentation:

#+begin_example
>>> (print (doc foreach))
Eagerly apply the given function to a sequence or list.
Example:
(foreach
  (fn (x) (println x))
  (range 20)) ; prints 0 to 20. Returns ().

(foreach
  (fn (x) (println x))
  (take 5 (map (fn (x) (* x x x x x x)) (range)))) ; prints 0, 1, 64, 729, 4096
#+end_example

The general goal is to be as helpful as possible. So stacktraces include more
information than you'd usually get, such as arguments.

For example, the following program will fail:

#+begin_src elisp
(defn bottom (x) (% x 2))
(defn middle (x) (bottom x))
(defn top () (middle "a"))
(top)
#+end_src

And give this helpful stacktrace:

#+begin_example
Error: BadTypes

Stacktrace:
  - Remainder requires left and right are num types, was given "a" % 2
  - Error in Fn<%, 2, [ ]>, with args ("a" 2)
  - Error in Fn<bottom, 1, [ x ]>, with args ("a")
  - Error in Fn<middle, 1, [ x ]>, with args ("a")
  - Error in Fn<top, 0, [ ]>, with args ()
#+end_src
#+end_example

*** Convenient FFI

x9 offers easy and convenient embedding into other rust programs.

#+begin_src rust
  use x9::ffi::{x9Interpreter, ForeignData};

  let interpreter = x9Interpreter::new();
  let res = interpreter.run_program::<u64>("(+ 1 1)").unwrap();
  assert_eq!(res, 2);
#+end_src

You can interface your own types in x9 with the =ForeignData= trait, and
add foreign functions into the interpreter. To maximize convenience foreign functions
are typed in terms of their own datatypes - not x9's Expr type.

#+begin_src rust
  let interpreter = x9Interpreter::new();
  let my_sum_fn = |args: Vec<u64>| Ok(args.iter().sum());
  // Add the my-sum to interpreter
  interpreter.add_function("my-sum", 1, Arc::new(my_sum_fn));

  // And verify we get u64 with value 6 out of it.
  assert_eq!(interpreter.run_program::<u64>("(my-sum 1 2 3)").unwrap(), 6);
#+end_src

More interesting is the fact that functions added to the interpreter
in a strongly typed way, allowing us to mix types!

#+begin_src rust
  // Recall that my-sum is a Fn(Vec<u64>) -> u64
  let string_res = interpreter.run_program::<String>("(my-sum 1 2 3)").unwrap();
  // And we get a string out it!
  assert_eq!(string_res, "6".to_string());
#+end_src

The reason it works is we embed the type information into the function
added to the interpreter, and x9's =Expr= type acts as a bridge between types.

For more info see the =ffi.rs= example in the examples folder!

You can run the example with:

#+begin_example
cargo run --example ffi
#+end_example


*** Speedy Iterators

Certain constructs like =(range)= and =map= are backed by lazy iterators, making them pretty fast.
